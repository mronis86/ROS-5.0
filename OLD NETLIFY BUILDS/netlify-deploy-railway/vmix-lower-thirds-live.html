<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lower Thirds Live Data - VMIX</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background-color: #000;
            color: #0f0;
            margin: 0;
            padding: 20px;
            font-size: 12px;
        }
        .status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 10px;
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #0f0;
            border-radius: 4px;
        }
        .connected { color: #0f0; }
        .disconnected { color: #f00; }
        .data-container {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .info {
            margin-bottom: 20px;
            padding: 10px;
            background: rgba(0, 100, 255, 0.1);
            border: 1px solid #0af;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="status">
        <div>Status: <span id="connectionStatus" class="disconnected">Disconnected</span></div>
        <div>Last Update: <span id="lastUpdate">Never</span></div>
        <div>Data Size: <span id="dataSize">0</span> chars</div>
    </div>

    <div class="info">
        <strong>VMIX Lower Thirds Live Data</strong><br>
        Format: <span id="format">XML</span> | 
        Event ID: <span id="eventId">Loading...</span><br>
        Updates: Real-time via WebSocket (Low Egress)<br>
        <small>This page connects to Railway WebSocket and generates data in your browser.</small>
    </div>

    <div class="data-container" id="dataOutput">Loading...</div>

    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        // Get parameters from URL
        const urlParams = new URLSearchParams(window.location.search);
        const eventId = urlParams.get('eventId');
        const format = urlParams.get('format') || 'xml'; // xml or csv

        document.getElementById('eventId').textContent = eventId || 'Not specified';
        document.getElementById('format').textContent = format.toUpperCase();

        if (!eventId) {
            document.getElementById('dataOutput').textContent = 'ERROR: Event ID is required. Add ?eventId=YOUR_EVENT_ID to the URL';
            document.getElementById('connectionStatus').textContent = 'Error';
            throw new Error('Event ID required');
        }

        // Railway WebSocket connection
        const RAILWAY_URL = 'https://ros-50-production.up.railway.app';
        let socket = null;
        let currentData = null;

        function updateStatus(connected) {
            const statusEl = document.getElementById('connectionStatus');
            statusEl.textContent = connected ? 'Connected' : 'Disconnected';
            statusEl.className = connected ? 'connected' : 'disconnected';
        }

        function generateXML(data) {
            if (!data || !data.schedule_items) {
                return `<?xml version="1.0" encoding="UTF-8"?>
<data>
  <timestamp>${new Date().toISOString()}</timestamp>
  <event_id>${eventId}</event_id>
  <lower_thirds>
  </lower_thirds>
</data>`;
            }

            const scheduleItems = data.schedule_items;
            const lowerThirdsData = [];

            scheduleItems.forEach(item => {
                const speakers = [];
                
                if (item.speakersText) {
                    try {
                        const speakersArray = typeof item.speakersText === 'string' 
                            ? JSON.parse(item.speakersText) 
                            : item.speakersText;
                        
                        if (Array.isArray(speakersArray)) {
                            speakersArray.forEach(speaker => {
                                speakers.push({
                                    title: speaker.fullName || speaker.name || '',
                                    subtitle: [speaker.title, speaker.org].filter(Boolean).join(', '),
                                    photo: speaker.photoLink || ''
                                });
                            });
                        }
                    } catch (e) {
                        console.error('Error parsing speakers:', e);
                    }
                }

                lowerThirdsData.push({
                    id: String(item.id),
                    cue: item.customFields?.cue || '',
                    program: item.programType || '',
                    segmentName: item.segmentName || '',
                    speakers
                });
            });

            const xmlHeader = '<?xml version="1.0" encoding="UTF-8"?>';
            const items = lowerThirdsData.map(item => {
                const speakers = new Array(21).fill('');
                if (item.speakers && item.speakers.length > 0) {
                    item.speakers.forEach((speaker, speakerIndex) => {
                        if (speakerIndex < 7) {
                            const baseIdx = speakerIndex * 3;
                            speakers[baseIdx] = speaker.title || '';
                            speakers[baseIdx + 1] = speaker.subtitle || '';
                            speakers[baseIdx + 2] = speaker.photo || '';
                        }
                    });
                }
                return `
    <item>
      <id>${item.id}</id>
      <cue><![CDATA[${item.cue || ''}]]></cue>
      <program><![CDATA[${item.program || ''}]]></program>
      <segment_name><![CDATA[${item.segmentName || ''}]]></segment_name>
      <speaker_1_name><![CDATA[${speakers[0]}]]></speaker_1_name>
      <speaker_1_title_org><![CDATA[${speakers[1]}]]></speaker_1_title_org>
      <speaker_1_photo><![CDATA[${speakers[2]}]]></speaker_1_photo>
      <speaker_2_name><![CDATA[${speakers[3]}]]></speaker_2_name>
      <speaker_2_title_org><![CDATA[${speakers[4]}]]></speaker_2_title_org>
      <speaker_2_photo><![CDATA[${speakers[5]}]]></speaker_2_photo>
      <speaker_3_name><![CDATA[${speakers[6]}]]></speaker_3_name>
      <speaker_3_title_org><![CDATA[${speakers[7]}]]></speaker_3_title_org>
      <speaker_3_photo><![CDATA[${speakers[8]}]]></speaker_3_photo>
      <speaker_4_name><![CDATA[${speakers[9]}]]></speaker_4_name>
      <speaker_4_title_org><![CDATA[${speakers[10]}]]></speaker_4_title_org>
      <speaker_4_photo><![CDATA[${speakers[11]}]]></speaker_4_photo>
      <speaker_5_name><![CDATA[${speakers[12]}]]></speaker_5_name>
      <speaker_5_title_org><![CDATA[${speakers[13]}]]></speaker_5_title_org>
      <speaker_5_photo><![CDATA[${speakers[14]}]]></speaker_5_photo>
      <speaker_6_name><![CDATA[${speakers[15]}]]></speaker_6_name>
      <speaker_6_title_org><![CDATA[${speakers[16]}]]></speaker_6_title_org>
      <speaker_6_photo><![CDATA[${speakers[17]}]]></speaker_6_photo>
      <speaker_7_name><![CDATA[${speakers[18]}]]></speaker_7_name>
      <speaker_7_title_org><![CDATA[${speakers[19]}]]></speaker_7_title_org>
      <speaker_7_photo><![CDATA[${speakers[20]}]]></speaker_7_photo>
    </item>`;
            }).join('');

            return xmlHeader + `
<data>
  <timestamp>${new Date().toISOString()}</timestamp>
  <event_id>${eventId}</event_id>
  <lower_thirds>
    ${items}
  </lower_thirds>
</data>`;
        }

        function generateCSV(data) {
            if (!data || !data.schedule_items) {
                return 'Row,Cue,Program,Segment Name,Speaker 1 Name,Speaker 1 Title/Org,Speaker 1 Photo,Speaker 2 Name,Speaker 2 Title/Org,Speaker 2 Photo,Speaker 3 Name,Speaker 3 Title/Org,Speaker 3 Photo,Speaker 4 Name,Speaker 4 Title/Org,Speaker 4 Photo,Speaker 5 Name,Speaker 5 Title/Org,Speaker 5 Photo,Speaker 6 Name,Speaker 6 Title/Org,Speaker 6 Photo,Speaker 7 Name,Speaker 7 Title/Org,Speaker 7 Photo\n';
            }

            const scheduleItems = data.schedule_items;
            let csv = 'Row,Cue,Program,Segment Name,Speaker 1 Name,Speaker 1 Title/Org,Speaker 1 Photo,Speaker 2 Name,Speaker 2 Title/Org,Speaker 2 Photo,Speaker 3 Name,Speaker 3 Title/Org,Speaker 3 Photo,Speaker 4 Name,Speaker 4 Title/Org,Speaker 4 Photo,Speaker 5 Name,Speaker 5 Title/Org,Speaker 5 Photo,Speaker 6 Name,Speaker 6 Title/Org,Speaker 6 Photo,Speaker 7 Name,Speaker 7 Title/Org,Speaker 7 Photo\n';

            scheduleItems.forEach((item, index) => {
                const speakers = new Array(21).fill('');
                
                if (item.speakersText) {
                    try {
                        const speakersArray = typeof item.speakersText === 'string' 
                            ? JSON.parse(item.speakersText) 
                            : item.speakersText;
                        
                        if (Array.isArray(speakersArray)) {
                            speakersArray.forEach((speaker, speakerIndex) => {
                                if (speakerIndex < 7) {
                                    const baseIdx = speakerIndex * 3;
                                    speakers[baseIdx] = speaker.fullName || speaker.name || '';
                                    speakers[baseIdx + 1] = [speaker.title, speaker.org].filter(Boolean).join(', ');
                                    speakers[baseIdx + 2] = speaker.photoLink || '';
                                }
                            });
                        }
                    } catch (e) {
                        console.error('Error parsing speakers:', e);
                    }
                }

                const escapeCsv = (str) => `"${String(str || '').replace(/"/g, '""')}"`;
                const cue = item.customFields?.cue || '';
                const program = item.programType || '';
                const segmentName = item.segmentName || '';
                
                csv += `${index + 1},${escapeCsv(cue)},${escapeCsv(program)},${escapeCsv(segmentName)}`;
                for (let i = 0; i < 21; i++) {
                    csv += `,${escapeCsv(speakers[i])}`;
                }
                csv += '\n';
            });

            return csv;
        }

        function updateDisplay(data) {
            currentData = data;
            const output = format === 'csv' ? generateCSV(data) : generateXML(data);
            document.getElementById('dataOutput').textContent = output;
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
            document.getElementById('dataSize').textContent = output.length;
        }

        async function loadInitialData() {
            try {
                const response = await fetch(`${RAILWAY_URL}/api/run-of-show-data/${eventId}`);
                if (!response.ok) throw new Error('Failed to fetch initial data');
                const data = await response.json();
                updateDisplay(data);
            } catch (error) {
                console.error('Error loading initial data:', error);
                document.getElementById('dataOutput').textContent = 'ERROR: Failed to load initial data. Check console for details.';
            }
        }

        function connectWebSocket() {
            console.log('Connecting to Railway WebSocket...');
            
            socket = io(RAILWAY_URL, {
                transports: ['websocket', 'polling'],
                reconnection: true,
                reconnectionDelay: 1000,
                reconnectionAttempts: 10
            });

            socket.on('connect', () => {
                console.log('âœ… Connected to Railway WebSocket');
                updateStatus(true);
                
                // Join the event room
                socket.emit('join-event', eventId);
                console.log('ðŸ“¡ Joined event room:', eventId);
            });

            socket.on('disconnect', () => {
                console.log('âŒ Disconnected from Railway WebSocket');
                updateStatus(false);
            });

            socket.on('connect_error', (error) => {
                console.error('âŒ WebSocket connection error:', error);
                updateStatus(false);
            });

            // Listen for run of show data updates
            socket.on('run-of-show-data-updated', (data) => {
                console.log('ðŸ“¡ Received data update via WebSocket');
                if (data && data.event_id === eventId) {
                    updateDisplay(data);
                }
            });

            // Listen for initial sync
            socket.on('initial-sync', async () => {
                console.log('ðŸ”„ Initial sync requested');
                await loadInitialData();
            });
        }

        // Initialize
        loadInitialData();
        connectWebSocket();

        // Reconnect if connection is lost
        setInterval(() => {
            if (!socket || !socket.connected) {
                console.log('ðŸ”„ Reconnecting...');
                connectWebSocket();
            }
        }, 5000);
    </script>
</body>
</html>
